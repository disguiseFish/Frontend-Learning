# monorepo
monorepo 是一种将多个项目代码存储在一个仓库里的软件开发策略，现如今非常多开源仓库、知名公司等广泛采用这种方式管理代码，例如：vue、antd 等；也有许多公司在积极拥抱 monorepo 技术。

为什么使用monorepo：
看似职责不够单一，代码糅合在一起，设计不够合理，但：
● 更容易实现代码复用(源码管理比依赖管理简单很多)，也更容易治理
● 更容易复用基础设施
● 更容易 CR
● 微前端/微服务化后，项目粒度有过度拆解的趋势，导致项目总量往往越来越多；强制 monorepo 能给高层带来更便捷的管理维度
● 更容易针对整个团队，设定统一的编码规范等；也能够规范许多开发行为
● 子项目间模块关系更透明，理论上更容易做集成部署；更容易做基础设施升级
● 倡导一种透明、公平、开放、共享的工程师文化，促进合作；
● 可能带来更高的开发效率；
● 其实，不过是一种分久必合合久必分的历史趋势罢了

当然他也会有缺点：
● 代码权限(如果需要的话)管理变得很复杂，git 维度下甚至做不到
● 上手成本更高，除了特定模块外，新人还需要串联了解子项目之间的依赖关系
● 本地开发对 IDE 要求更高
● 依赖管理、代码搜索、FG、分支模型、任务编排。。。blabla，最终整体对技术的要求会高很多(不过这本质是工程问题，不是 monorepo 问题)
● 单点失败直接影响整个项目工程(其实这也算是预期内的)

● 代码权限(如果需要的话)管理变得很复杂，git 维度下甚至做不到
● 上手成本更高，除了特定模块外，新人还需要串联了解子项目之间的依赖关系
● 本地开发对 IDE 要求更高
● 依赖管理、代码搜索、FG、分支模型、任务编排。。。blabla，最终整体对技术的要求会高很多(不过这本质是工程问题，不是 monorepo 问题)
● 单点失败直接影响整个项目工程(其实这也算是预期内的)

1.地址

2.工程化环境：
webpack
rush（版本收敛 关联发布 插件系统 循环依赖检测）
nx
turborepo

3.质检（link ts ut）
4.脚手架命令（rush init-project）
5.启动（npm i -g pnpm@8.5.0 @microsoft/rush@5.110.2 ）(rush update)
6.why monorepo? 
 (1)缺点：工程复杂度很高 依赖更新成本高
（2）优点： 更简单的代码复用 唯一真实 共用一套基础设施 高层视角的统一性
7.rush
 (1) 缺点：工程复杂度高  几乎没有中文资料
 (2) 优点： 更高级的monorepo方案 去除幽灵依赖  去除循环依赖  扩展性更强  适用于超大型项目 （适合很多人共同开发）
 8.大文件上传的架构
 （1）web page
 （2）node服务--接收文件 保存文件  把文件合并在一起
 （3）fs storage package 文件仓
 
 9.fs storage（文件仓--文件的读写文件的路径计算，精髓）
 （文件查找的实际运行逻辑）

 10.file-server
  （方法： 接受请求，处理参数，再调用方法去判断某个分片是否存在，存在就返回true，保存文件）
  